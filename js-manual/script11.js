// ---- Об'єктна модель документа ----
// Коли ми працюємо з браузером, доступний функціонал складається з декількох модулів, оскільки JavaScript не має інструментів для роботи з браузером. 
// C:\Users\Admin\Documents\GitHub\js-repetition\images\browser-js.png

// Об'єктна модель документа (Document Object Model) - незалежний від мови інтерфейс для роботи з HTML-документом. Містить набір властивостей і методів, що дозволяють шукати, створювати і видаляти елементи, реагувати на дії користувача і багато іншого. Тобто з'єднує сторінку з мовою програмування.

// DOM - це відображення HTML-документа, деревоподібна структура, в якій кожен вузол - це JavaScript-об'єкт з властивостями і методами, що становить частину HTML-документа. Кожен елемент в документі, весь документ в цілому, заголовок, посилання, абзац - це частини DOM цього документа, тому всі вони можуть бути змінені з JavaScript-коду.

// Об'єктна модель браузера (Browser Object Model) - незалежний від мови інтерфейс для роботи з вкладкою браузера. Містить набір властивостей і методів, що дозволяють отримати доступ безпосередньо до поточної вкладки і ряду функцій браузера. Містить об'єкт роботи з історією навігації, місцем розташування та багато іншого.

// --- HTML-документ і DOM ---
// Згідно з DOM-моделлю, кожен тег утворює окремий елемент-вузол, кожен фрагмент тексту - текстовий елемент. HTML-документ - це ієрархічне дерево, в якому у кожного елемента (крім кореневого) є тільки один батьківський елемент, тобто елемент, всередині якого він розташовується. Це дерево утворюється за рахунок вкладеної структури тегів і текстових елементів.
// C:\Users\Admin\Documents\GitHub\js-repetition\images\dom-tree.png

// Щоб відобразити HTML-документ, браузер спочатку перетворює його у формат, який він розуміє - DOM. Рушій браузера має спеціальний фрагмент коду - HTML-парсер, який використовується для перетворення HTML в DOM.

// В HTML вкладеність визначає відносини батько-дитина між елементами. В DOM об'єкти пов'язані у деревоподібній структурі даних, фіксуючи ці відносини.

// Браузер будує DOM поступово, щойно надходять перші фрагменти коду, він починає парсити HTML, додаючи вузли у деревоподібну структуру.
// C:\Users\Admin\Documents\GitHub\js-repetition\images\html-parser.gif

// Після того, як DOM-дерево побудовано, у ньому можна знайти елемент за допомогою JavaScript і виконувати з ним певні дії, оскільки кожен елемент має інтерфейс з безліччю властивостей і методів.
// C:\Users\Admin\Documents\GitHub\js-repetition\images\js-engine.gif

// --- DOM-дерево ----
// Візуалізуємо дерево HTML-документа
// <!DOCTYPE html>
// <html>
//   <head>
//     <title>Document title</title>
//   </head>
//   <body>
//     <h1>Page title</h1>
//     <ul>
//       <li><a href="#">Link 1</a></li>
//       <li><a href="#">Link 2</a></li>
//     </ul>
//   </body>
// </html>
// C:\Users\Admin\Documents\GitHub\js-repetition\images\live-dom-tree.png
// У цьому дереві виділені два типи вузлів.

// Вузли-елементи (element node) - утворюються тегами, звичайним чином одні елементи вкладені в інші. Структура дерева утворена виключно за рахунок них.
// Текстові вузли (text node) - утворюються текстом всередині елементів. Текстовий вузол містить тільки рядок тексту і не може мати дочірніх елементів, тобто він завжди на найнижчому рівні ієрархії. Пробіли і перенесення рядків - це теж текстові вузли.
// З цього правила є винятки: пробіли до head ігноруються, а будь-який вміст після body не створює елемент, браузер переносить його в кінець 'body'.


// ---- Навігація по DOM ----
// DOM надає широкий спектр можливостей для роботи з елементом і його вмістом, але для цього, спочатку потрібно отримати посилання на нього. Доступ до DOM починається з об'єкта document, з нього можна дістатися до будь-яких елементів.
// document - це частина глобального об'єкта window, який доступний у скрипті, коли він виконується в браузері. Так само як alert, console.log, prompt і багато інших.

// Елементи DOM-дерева мають ієрархічне відношення один до іншого. Для опису відносин використовуються терміни предок (ancestor), нащадок (descendant), батько (parent), дитина (child) і сусід (sibling).
// - Найвищий елемент називається кореневим (root node).
// - Кожен елемент, крім кореневого, має тільки одного батьківського.
// - У елемента може бути скільки завгодно дітей.
// - Сусіди - це елементи зі спільним батьківським елементом.
// - Дочірні елементи (діти) - елементи, які знаходяться безпосередньо всередині поточного (перша вкладеність).
// - Нащадки - усі елементи, які знаходяться у поточному, разом з їхніми дітьми, дітьми їхніх дітей тощо. Тобто все на зразок дерева.
// C:\Users\Admin\Documents\GitHub\js-repetition\images\dom-traversal.png

// Для навігації по цій ієрархії елементи мають наступні властивості.
/*
    elem.children - псевдомасив, зберігає тільки дочірні вузли-елементи, тобто ті, що відповідають тегам.
    elem.firstElementChild - вибере перший дочірній вузол-елемент всередині elem.
    elem.lastElementChild - вибере останній дочірній вузол-елемент всередині elem.
    
    DOM-колекції, як-от childNodes і children - псевдомасиви (NodeList), у них немає більшості методів масиву.
*/


// ----- Пошук елементів -----
// Отже, ми вже знаємо що DOM-елемент - це об'єкт з властивостями і методами. Саме час навчитися швидко знаходити елемент за довільним CSS-селектором. Група методів elem.querySelector* - це сучасний стандарт для пошуку елементів. Вони дозволяють знайти елемент або групу елементів за CSS-селектором будь-якої складності.

// element.querySelector(selector);
// Використовується, якщо необхідно знайти тільки один, найчастіше унікальний елемент.

// - Повертає перший знайдений елемент всередині element, що відповідає CSS-селектору selector.
// - Якщо нічого не знайдено, поверне null.

// element.querySelectorAll(selector);
// Використовується, якщо необхідно знайти колекцію елементів, тобто отримати масив посилань на елементи з однаковим селектором. Наприклад, всі елементи списку з класом menu-item.

// - Повертає псевдомасив всіх елементів всередині element, які відповідають CSS-селектору selector.
// - Якщо нічого не знайдено, поверне порожній масив.


// ---- Властивості та атрибути -----
// Під час побудови DOM-дерева, деякі стандартні HTML-атрибути стають властивостями елементів. Подивимося на декілька властивостей, які часто використовуються.

/* 
    value - містить поточний текстовий контент елементів форм.
    checked - зберігає стан чекбокса або радіокнопки.
    name - зберігає значення, вказане в HTML-атрибуті name.
    src - шлях до зображення тегу <img>.
*/

// Властивість textContent - elem.textContent повертає текстовий контент всередині елемента. Доступний для читання і запису. Неважливо, що буде передано в textContent, дані завжди будуть записані як текст.

// Властивість classList
/* 
У властивості classList зберігається об'єкт з методами для роботи з класами елемента.
    
    elem.classList.contains(cls) - повертає true або false, залежно від наявності класу cls в елемента.
    elem.classList.add(cls) - додає клас cls до списку класів елемента.
    elem.classList.remove(cls) - видаляє клас cls зі списку класів елемента.
    elem.classList.toggle(cls) - якщо відсутній клас cls, то додає його, якщо - присутній, навпаки - видаляє.
    elem.classList.replace(oldClass, newClass) - замінює існуючий клас oldClass на вказаний newClass.

*/

// Властивість style - використовується для читання та зміни інлайнових стилів. Повертає об'єкт CSSStyleDeclaration, який містить список усіх властивостей, визначених тільки у вбудованих стилях елемента, а не увесь CSS. Під час запису властивості записуються в camelCase, тобто background-color перетворюється на element.style.backgroundColor тощо.

// const button = document.querySelector(".btn");

// button.style.backgroundColor = "teal";
// button.style.fontSize = "24px";
// button.style.textAlign = "center";

// console.log(button.style); // inline styles object


// На практиці стилізація елементів виконується шляхом додавання CSS-класів. Властивість style використовується для додавання будь-яких динамічних стилів, наприклад, під час анімації.

// Атрибути
// DOM-елементам відповідають HTML-теги, які містять текстові атрибути. Доступ до атрибутів здійснюється за допомогою стандартних методів. Ці методи працюють зі значенням, яке знаходиться в HTML.
/*
    elem.hasAttribute(name) - перевіряє наявність атрибута, повертає true або false.
    elem.getAttribute(name) - отримує значення атрибута і повертає його.
    elem.setAttribute(name, value) - встановлює атрибут.
    elem.removeAttribute(name) - видаляє атрибут.
    elem.attributes - властивість, що повертає об'єкт усіх атрибутів елемента.
*/

// data-атрибути

// // Для отримання значення data-атрибута використовується властивість dataset, після якого стоїть ім'я атрибута. Тобто data- відкидається, а інша частина імені записується як ім'я властивості об'єкта.
// const saveBtn = document.querySelector('button[data-action="save"]');
// console.log(saveBtn.dataset.action); // "save"

// const closeBtn = document.querySelector('button[data-action="close"]');
// console.log(closeBtn.dataset.action); // "close"

// ---- Створення та видалення елементів -----
// DOM API дозволяє не тільки вибирати або змінювати вже існуючі, але й видаляти, а також створювати нові елементи, після чого додавати їх в документ.

// Створення
// document.createElement(tagName);

// Створює елемент з ім'ям tagName і повертає посилання на нього як результат свого виконання. tagName - це рядок, що вказує тип елемента, який створюється. Елемент створюється в пам'яті, в DOM його ще немає.
const heading = document.createElement("h1");
console.log(heading); // <h1></h1>

heading.textContent = "This is a heading";
console.log(heading); // <h1>This is a heading</h1>

const image = document.createElement("img");
image.src = "https://placeimg.com/640/480/nature";
image.alt = "Nature";
console.log(image); // <img src="https://placeimg.com/640/480/nature" alt="Nature" />

// Додавання
// Щоб створений елемент відображався на сторінці, його необхідно додати до вже існуючого елемента в DOM-дереві. Припустимо, що додаємо до певного елемента element, для цього існують методи.
/* 
    element.append(el1, el2, ...) - додає один або декілька елементів після всіх дітей елемента element.
    element.prepend(el1, el2, ...) - додає один або декілька елементів перед усіма дітьми елемента element.
    element.after(el1, el2, ...) - додає один або декілька елементів після елемента element.
    element.before(el1, el2, ...) - додає один або декілька елементів перед елементом element.

    У всіх цих методах el - це елементи або рядки, в будь-якому поєднанні і кількості. Рядки додаються як текстові вузли.

    Якщо елемент для додавання вже знаходиться в DOM, то він видаляється зі свого старого місця і додається у нове. З цього випливає правило - один і той самий елемент не може бути одночасно у двох місцях.
*/

// Видалення
// elem.remove();

// Для того, щоб видалити елемент, використовується метод remove(). Він викликається на елементі elem, який необхідно видалити

// Оптимізація роботи з DOM
// Сучасні браузери намагаються оптимізувати процес відтворення сторінки без втручання розробника. Проте, зміна DOM-дерева - це дорога операція, тому необхідно намагатися мінімізувати кількість звернень до DOM.

// Repaint - відбувається, коли зміни торкнулися стилів, що впливають на зовнішній вигляд елемента, але не на геометрію. Наприклад opacity, background-color, visibility і outline. Браузер повторно створює елемент, з урахуванням нового стилю. Також перевіряється видимість інших елементів, один або більше можуть виявитися прихованими під елементом, що змінив зовнішній вигляд.

// Reflow - відбувається, коли зміни впливають на вміст, структуру документу, положення елементів. Відбувається перерахунок позиціонування і розмірів, що призводить до повторного створення частини або всього документу. Зміна розміру одного батьківського контейнера вплине на всіх його дітей і предків. Має значно більший вплив на продуктивність, ніж repaint.

// Усі перераховані вище операції блокують браузер. Сторінка не може виконувати жодні інші операції у той час, коли відбувається reflow або repaint. Причинами можуть бути:
/*
    - Маніпуляції з DOM (додавання, видалення, зміна, перестановка елементів)
    - Зміна вмісту, зокрема тексту в полях форм
    - Розрахунок або зміна CSS-властивостей
    - Додавання і видалення таблиць стилів
    - Маніпуляції з атрибутом class
    - Маніпуляції з вікном браузера (зміни розмірів, прокручування)
    - Активація псевдокласів (наприклад, ':hover')

*/

// Властивість innerHTML - ще один спосіб створити DOM-елементи і помістити їх в дерево - це використовувати рядки з тегами і дозволити браузеру зробити всю важку роботу. У такого підходу є свої плюси і мінуси.

// Читання - властивість innerHTML зберігає вміст елемента, включно з тегами, у вигляді рядка. Значення, що повертається, - це завжди валідний HTML-код.

// Зміна - вастивість innerHTML доступна і для читання, і для запису. Якщо записати в неї рядок з HTML-тегами, то браузер під час парсингу рядка перетворить їх у валідні елементи і додасть в DOM-дерево.

// Якщо у властивість innerHTML записати порожній рядок, то вміст елемента буде очищено. Це простий і швидкий спосіб видалення всього вмісту.

// За такого підходу, на відміну від document.createElement(), ми не отримуємо посилання на створений DOM-елемент. Це перший крок на шляху до шаблонізації - створення великої кількості однотипної розмітки з різними даними за наперед визначеним шаблоном. Наприклад, як у списку товарів інтернет магазину тощо.

// Однотипна (шаблонна) розмітка створюється із масиву даних. Прийом полягає у перебиранні цього масиву і складанні одного рядка з HTML-тегами, який потім записуємо в innerHTML елемента.

// Додавання
// Зміна elem.innerHTML повністю видалить і повторно створить всі нащадки елемента elem. Якщо елемент спочатку не був порожній, то виникнуть додаткові витрати на серіалізацію вже існуючої розмітки, а це погано.

// Використовуйте властивість elem.innerHTML для додавання тільки тоді, коли елемент elem - порожній, або якщо потрібно повністю замінити його вміст.

// Метод insertAdjacentHTML()
// Сучасний метод для додавання рядка з HTML-тегами перед, після або всередину елемента. Вирішує проблему innerHTML з повторною серіалізацією вмісту елемента під час додавання розмітки до вже існуючої.
// elem.insertAdjacentHTML(position, string);
// Аргумент position - це рядок, позиція щодо елемента elem. Приймає одне з чотирьох значень.
// C:\Users\Admin\Documents\GitHub\js-repetition\images\insert-adjacent.png
/*
    "beforebegin" - перед elem
    "afterbegin" - всередині elem, перед усіма дітьми
    "beforeend" - всередині elem, після усіх дітей
    "afterend" - після elem

    "beforebegin" і "afterend" працюють тільки тоді, коли elem вже знаходиться в DOM-дереві.
*/

// ---- Підключення скриптів -----
// Завантаження і виконання скрипта, зазначеного в тезі <script> без будь-яких атрибутів, блокують обробку HTML-документа і побудову DOM. Це проблема.
// <script src="path-to-script.js"></script>

// Коли аналізатор зустрічає такий тег, обробка HTML-документа припиняється і починається завантаження файлу скрипта, зазначеного в атрибуті src. Після завантаження скрипт виконується, і тільки потім відновлюється обробка HTML. Це називається «блокуючий» скрипт.

// Атрибути defer та async були введені, щоб дати розробникам можливість краще контролювати спосіб завантаження скриптів, і коли саме їх виконувати.
// <script defer src="path-to-script.js"></script>

// Атрибут defer вказує браузеру завантажувати файл скрипта у фоновому режимі, паралельно обробці HTML-документа і побудові DOM. Скрипт буде виконаний тільки після того, як HTML-документ був оброблений, а DOM побудований. Такі скрипти не блокують побудову DOM-дерева і гарантовано виконуються у тому порядку, в якому вказані в HTML-документі.
// C:\Users\Admin\Documents\GitHub\js-repetition\images\defer.png

// Атрибут async
// <script async src="path-to-script.js"></script>

// Завантаження скрипта з атрибутом async не блокує побудову DOM, але він виконується відразу після завантаження. Це означає, що такі скрипти можуть заблокувати побудову DOM, і виконуються у довільному порядку.
// C:\Users\Admin\Documents\GitHub\js-repetition\images\async.png










