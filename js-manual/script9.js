// ---  Контекст виконання функції ---

// Контекст у JavaScript схожий на контекст у реченні:
/*
 - Петя біжить швидко, тому що Петя намагається зловити поїзд.
 - Петя біжить швидко, тому що він намагається зловити поїзд.
*/
// Друге речення звучить лаконічніше. Підмет речення - Петя, і ми можемо сказати, що контекст речення - це Петя, тому що він у центрі уваги у цей конкретний час у реченні. Навіть займенник «хто» стосується Петі.

// // Петя біжить швидко, тому що Петя намагається зловити поїзд.
// const petya = {
//     username: "Petya",
//     showName() {
//       console.log(petya.username);
//     },
//   };
  
//   petya.showName();

// Звернення до властивостей об'єкта всередині методів, використовуючи ім'я самого об'єкта, - аналогічно використанню Петя, замість він.

// Всередині функцій можна використовувати зарезервоване ключове слово this. Під час виконання функції, в this записується посилання на об'єкт, в контексті якого вона була викликана. Таким чином, в тілі функції ми можемо отримати доступ до властивостей і методів цього об'єкта.

// // Петя біжить швидко, тому що він (this) намагається зловити поїзд.
// const petya = {
//     username: "Petya",
//     showName() {
//       console.log(this.username);
//     },
//   };
  
//   petya.showName();

// // Розглянемо приклад з колекцією книг.
// const bookShelf = {
//     authors: ["Бернард Корнуелл", "Роберт Шеклі"],
//     getAuthors() {
//       return this.authors;
//     },
//     addAuthor(authorName) {
//       this.authors.push(authorName);
//     },
//   };
  
//   console.log(bookShelf.getAuthors()); // ["Бернард Корнуелл", "Роберт Шеклі"]
//   bookShelf.addAuthor("Лі Таніт");
//   console.log(bookShelf.getAuthors()); // ["Бернард Корнуелл", "Роберт Шеклі", "Лі Таніт"]

  // Методи getAuthors і addAuthor - це функції (методи об'єкта), які викликаються в контексті об'єкта bookShelf. Під час їх виконання в this записується посилання на об'єкт bookShelf і ми можемо звернутися до його властивостей і методів.



// ---- Правила визначення this -----
// Необхідно засвоїти лише одне правило для визначення this - значення контексту всередині функції (не стрілочної) визначається не на момент її створення, а на момент виклику. Тобто значення this визначається тим, як викликається функція, а не де вона була оголошена.

// --- this у глобальній області видимості
// // У глобальній області видимості, якщо скрипт виконується не в суворому режимі, this посилається на об'єкт window. В суворому режимі значення this, в глобальній області видимості, буде undefined.
// function foo() {
//     console.log(this);
//   }
  
//   foo(); // window без "use strict" і undefined з "use strict"

// --- this в методі об'єкта
// // Якщо функція була викликана як метод об'єкта, то контекст буде посилатися на об'єкт, частиною якого є метод.
// const petya = {
//     username: "Petya",
//     showThis() {
//       console.log(this);
//     },
//     showName() {
//       console.log(this.username);
//     },
//   };
  
//   petya.showThis(); // {username: "Petya", showThis: ƒ, showName: ƒ}
//   petya.showName(); // 'Petya'

// Розглянемо складніший приклад для кращого розуміння.
/*
    - Спочатку створимо функцію в глобальній області видимості і викличемо її.
    - Після чого, присвоїмо її у властивість об'єкта і викличемо як метод цього об'єкта.
*/
// function showThis() {
//     console.log("this in showThis: ", this);
//   }

// // Викликаємо у глобальному контексті
// showThis(); // this in showThis: undefined

// const user = {
//     username: "Mango",
//   };
  
// // Записуємо посилання на функцію у властивість об'єкта
// // Зверніть увагу, що це не виклик - немає ()
// user.showContext = showThis;

// // Викликаємо функцію в контексті об'єкта
// // this буде вказувати на поточний об'єкт, в контексті якого здійснюється виклик, а не на глобальний об'єкт.
// user.showContext(); // this in showThis: {username: "Mango", showContext: ƒ}


// --- this в callback-функціях
// // Передаючи методи об'єкта як колбек-функції, контекст не зберігається. Колбек - це посилання на метод, яке присвоюється як значення параметра, що викликається без об'єкта.
// const customer = {
//     firstName: "Jacob",
//     lastName: "Mercer",
//     getFullName() {
//       return `${this.firstName} ${this.lastName}`;
//     },
//   };

//   function makeMessage(callback) {
//     // callback() - це виклик методу getFullName без об'єкта
//     console.log(`Обробляємо заявку від ${callback()}.`);
//   }

//   makeMessage(customer.getFullName); // Буде помилка у виклику функції
// // Вирішення цієї проблеми розглядається у секції про метод bind() і методи об'єкта.


// --- this у стрілочних функціях
// // Стрілочні функції не мають свого this. На відміну від звичайних функцій, змінити значення this всередині стрілки після її оголошення - неможливо.
// // Контекст всередині стрілки визначається місцем її оголошення, а не виклику, і посилається на контекст батьківської функції.
// // Стрілочні функції також ігнорують наявність суворого режиму. Якщо стрілка запам'ятала глобальний контекст, то this в ній буде містити посилання на window, незалежно від того, чи виконується скрипт в суворому режимі.
// const showThis = () => {
//     console.log("this in showThis: ", this);
// };
  
// showThis(); // this in showThis: undefined
  
// const user = {
//     username: "Mango",
// };
// user.showContext = showThis;
  
// user.showContext(); // this in showThis: undefined


// Приклад - непрактичний, але чудово показує як працює контекст для стрілок. Значення контексту береться з батьківської області видимості.
// const hotel = {
//     username: "Resort hotel",
//     showThis() {
//       const foo = () => {
//         // Стрілки запам'ятовують контекст під час оголошення з батьківської області видимості
//         console.log("this in foo: ", this);
//       };
  
//       foo();
//       console.log("this in showThis: ", this);
//     },
//   };
  
//   hotel.showThis();
//   // this in foo: {username: 'Resort hotel', showThis: ƒ}
//   // this in showThis: {username: 'Resort hotel',showThis: ƒ}


// --- Методи функцій ---
// Трапляються ситуації, коли функцію потрібно викликати в контексті об'єкта, при цьому функція не є його методом. Для цього у функцій є методи call, apply і bind.

// --- Метод call()
// foo.call(obj, arg1, arg2, ...)
// Метод call викличе функцію foo таким чином, що в this буде посилання на об'єкт obj, а також передасть аргументи arg1, arg2 тощо.

// function greetGuest(greeting) {
//     console.log(`${greeting}, ${this.username}.`);
//   }
  
//   const mango = {
//     username: "Манго",
//   };
//   const poly = {
//     username: "Полі",
//   };
  
//   greetGuest.call(mango, "Ласкаво просимо"); // Ласкаво просимо, Манго.
//   greetGuest.call(poly, "З прибуттям"); // З прибуттям, Полі.


// --- Метод apply
// Метод apply - це аналог методу call за винятком того, що синтаксис передачі аргументів вимагає не перерахування, а масив, навіть якщо аргумент всього один.
// foo.call(obj, arg1, arg2, ...)

// foo.apply(obj, [arg1, arg2, ...])
// Метод apply викличе функцію foo таким чином, що в this буде посилання на об'єкт obj, а також передасть елементи масиву як окремі аргументи arg1, arg2 тощо.

// function greetGuest(greeting) {
//     console.log(`${greeting}, ${this.username}.`);
//   }
  
//   const mango = {
//     username: "Манго",
//   };
//   const poly = {
//     username: "Полі",
//   };
  
//   greetGuest.apply(mango, ["Ласкаво просимо"]); // Ласкаво просимо, Манго.
//   greetGuest.apply(poly, ["З прибуттям"]); // З прибуттям, Полі.


// --- Метод bind()
// Методи call і apply викликають функцію «на місці», тобто відразу. Але у разі колбек-функцій, коли необхідно не відразу викликати функцію, а передати посилання на неї, причому з прив'язаним контекстом, використовується метод bind.
// foo.bind(obj, arg1, arg2, ...)
// Метод bind створює і повертає копію функції foo з прив'язаним контекстом obj і аргументами arg1, arg2 тощо. Утворюється копія функції, яку можна передати куди завгодно і викликати коли завгодно.
// function greet(clientName) {
//     return `${clientName}, ласкаво просимо в «${this.service}».`;
//   }
  
//   const steam = {
//     service: "Steam",
//   };
//   const steamGreeter = greet.bind(steam);
//   steamGreeter("Манго"); // "Манго, ласкаво просимо в «Steam»."
  
//   const gmail = {
//     service: "Gmail",
//   };
//   const gmailGreeter = greet.bind(gmail);
//   gmailGreeter("Полі"); // "Полі, ласкаво просимо в «Gmail»."

// --- bind() і методи об'єкта
// У разі передачі методів об'єкта як колбек-функцій, контекст не зберігається. Колбек - це посилання на метод, яка присвоюється як значення параметра, що викликається без об'єкта.
const customer = {
    firstName: "Jacob",
    lastName: "Mercer",
    getFullName() {
      return `${this.firstName} ${this.lastName}`;
    },
  };
  
  function makeMessage(callback) {
    // callback() - це виклик методу getFullName без об'єкта
    console.log(`Обробляємо заявку від ${callback()}.`);
  }
  
//   makeMessage(customer.getFullName); // Виникне помилка на момент виклику функції

// У суворому режимі, значення this в методі getFullName, викликаючи як колбек-функції callback(), буде undefined. Звертаючись до властивостей firstName і lastName, виникне помилка, оскільки undefined - це не об'єкт.

// Метод bind використовується для прив'язування контексту, передаючи методи об'єкта як колбек-функції. Передамо колбеком не оригінальний метод getFullName, а його копію з прив'язаним контекстом об'єкту customer.

// ❌ Було
// makeMessage(customer.getFullName); // Виникне помилка на момент виклику функції

// ✅ Стало
makeMessage(customer.getFullName.bind(customer)); // Обробляємо заявку від Jacob Mercer.
